// ============================================================
// Axon v4.4 — API Client (Agent 4 — BRIDGE)
// UNICO archivo que hace fetch(). 3-layer rule: R06.
//
// Mode: USE_MOCKS = true  → returns mock data (Phase P1)
//       USE_MOCKS = false → makes real fetch() calls (Phase P2+)
//
// Pattern:
//   api-client.ts (this file) → hooks → UI components
//   NUNCA fetch() outside this file.
// ============================================================

import type {
  PricingPlan, PlanAccessRule, Video, AdminScope,
  KwStudentNote, KwProfNote, VideoNote,
  QuizAttempt, QuizBundle, LearningProfile,
  TextAnnotation, SummaryReadingState,
  StudentStats, DailyActivity, CourseProgress,
  StudentProfile, StudySession, FlashcardReview, StudySummary,
  Course, Semester, Section, Topic, Summary, Keyword,
} from './types';

import {
  MOCK_PLANS, MOCK_PLAN_RULES,
  MOCK_VIDEOS,
  MOCK_ADMIN_SCOPES,
  MOCK_KW_STUDENT_NOTES, MOCK_KW_PROF_NOTES,
  MOCK_VIDEO_NOTES,
  MOCK_QUIZ_ATTEMPTS,
  MOCK_LEARNING_PROFILE,
  MOCK_TEXT_ANNOTATIONS,
  MOCK_STUDENT_STATS, MOCK_DAILY_ACTIVITY, MOCK_COURSE_PROGRESS,
  MOCK_READING_STATES,
  MOCK_STUDENT_PROFILE, MOCK_STUDY_SESSIONS, MOCK_FLASHCARD_REVIEWS,
  MOCK_STUDY_SUMMARIES,
  MOCK_COURSES, MOCK_SEMESTERS, MOCK_SECTIONS, MOCK_TOPICS,
  MOCK_SUMMARIES, MOCK_KEYWORDS,
} from './mock-data';

// ── Config ──────────────────────────────────────────────────────
const USE_MOCKS: boolean =
  typeof import.meta !== 'undefined' && import.meta.env?.VITE_USE_MOCKS === 'false' ? false : true;

const API_BASE_URL: string =
  (typeof import.meta !== 'undefined' && import.meta.env?.VITE_API_BASE_URL as string) || '/api';

let _authToken: string | null = null;

export function setApiAuthToken(token: string | null): void { _authToken = token; }
export function getApiAuthToken(): string | null { return _authToken; }

function authHeaders(): Record<string, string> {
  const h: Record<string, string> = { 'Content-Type': 'application/json' };
  if (_authToken) h['Authorization'] = `Bearer ${_authToken}`;
  return h;
}

function mockId(prefix: string): string { return `${prefix}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`; }
function delay(ms = 150): Promise<void> { return new Promise(r => setTimeout(r, ms)); }
function now(): string { return new Date().toISOString(); }

// ── In-memory mock stores ───────────────────────────────────────
let _plans = [...MOCK_PLANS];
let _planRules = [...MOCK_PLAN_RULES];
let _videos = [...MOCK_VIDEOS];
let _adminScopes = [...MOCK_ADMIN_SCOPES];
let _kwStudentNotes = [...MOCK_KW_STUDENT_NOTES];
let _kwProfNotes = [...MOCK_KW_PROF_NOTES];
let _videoNotes = [...MOCK_VIDEO_NOTES];
let _quizAttempts = [...MOCK_QUIZ_ATTEMPTS];
let _textAnnotations = [...MOCK_TEXT_ANNOTATIONS];
let _readingStates = [...MOCK_READING_STATES];
let _studentProfiles = [{ ...MOCK_STUDENT_PROFILE }];
let _studySessions = [...MOCK_STUDY_SESSIONS];
let _flashcardReviews = [...MOCK_FLASHCARD_REVIEWS];
let _studySummaries = [...MOCK_STUDY_SUMMARIES];
let _courses = [...MOCK_COURSES];
let _semesters = [...MOCK_SEMESTERS];
let _sections = [...MOCK_SECTIONS];
let _topics = [...MOCK_TOPICS];
let _summaries = [...MOCK_SUMMARIES];
let _keywords = [...MOCK_KEYWORDS];

// ════════════════════════════════════════════════════════════
// Plans
// ════════════════════════════════════════════════════════════
export async function getPlans(instId: string): Promise<PricingPlan[]> { if (USE_MOCKS) { await delay(); return _plans.filter(p => p.institution_id === instId); } const res = await fetch(`${API_BASE_URL}/institutions/${instId}/plans`, { headers: authHeaders() }); return (await res.json()).data; }
export async function createPlan(instId: string, plan: Partial<PricingPlan>): Promise<PricingPlan> { if (USE_MOCKS) { await delay(); const n: PricingPlan = { id: mockId('plan'), institution_id: instId, name: plan.name || 'Novo Plano', description: plan.description, price: plan.price ?? 0, currency: plan.currency || 'BRL', is_default: plan.is_default ?? false, is_trial: plan.is_trial ?? false, trial_duration_days: plan.trial_duration_days, max_students: plan.max_students, features: plan.features || [], created_at: now(), updated_at: now() }; _plans.push(n); return n; } const res = await fetch(`${API_BASE_URL}/institutions/${instId}/plans`, { method: 'POST', headers: authHeaders(), body: JSON.stringify(plan) }); return (await res.json()).data; }
export async function updatePlan(instId: string, planId: string, data: Partial<PricingPlan>): Promise<PricingPlan> { if (USE_MOCKS) { await delay(); const i = _plans.findIndex(p => p.id === planId); if (i === -1) throw new Error(`Plan ${planId} not found`); _plans[i] = { ..._plans[i], ...data, updated_at: now() }; return _plans[i]; } const res = await fetch(`${API_BASE_URL}/institutions/${instId}/plans/${planId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) }); return (await res.json()).data; }
export async function deletePlan(instId: string, planId: string): Promise<void> { if (USE_MOCKS) { await delay(); _plans = _plans.filter(p => p.id !== planId); return; } await fetch(`${API_BASE_URL}/institutions/${instId}/plans/${planId}`, { method: 'DELETE', headers: authHeaders() }); }

// Plan Rules
export async function getPlanRules(planId: string): Promise<PlanAccessRule[]> { if (USE_MOCKS) { await delay(); return _planRules.filter(r => r.plan_id === planId); } const res = await fetch(`${API_BASE_URL}/plans/${planId}/rules`, { headers: authHeaders() }); return (await res.json()).data; }
export async function createPlanRule(planId: string, rule: Partial<PlanAccessRule>): Promise<PlanAccessRule> { if (USE_MOCKS) { await delay(); const n: PlanAccessRule = { id: mockId('rule'), plan_id: planId, resource_type: rule.resource_type || 'course', resource_id: rule.resource_id || '', permission: rule.permission || 'read', created_at: now() }; _planRules.push(n); return n; } const res = await fetch(`${API_BASE_URL}/plans/${planId}/rules`, { method: 'POST', headers: authHeaders(), body: JSON.stringify(rule) }); return (await res.json()).data; }

// Videos
export async function getVideos(summaryId: string): Promise<Video[]> { if (USE_MOCKS) { await delay(); return _videos.filter(v => v.summary_id === summaryId); } const res = await fetch(`${API_BASE_URL}/summaries/${summaryId}/videos`, { headers: authHeaders() }); return (await res.json()).data; }
export async function createVideo(summaryId: string, video: Partial<Video>): Promise<Video> { if (USE_MOCKS) { await delay(); const n: Video = { id: mockId('vid'), summary_id: summaryId, title: video.title || 'Novo Video', url: video.url || '', duration_ms: video.duration_ms, thumbnail_url: video.thumbnail_url || null, order_index: video.order_index ?? _videos.filter(v => v.summary_id === summaryId).length, created_at: now(), updated_at: now(), created_by: 'demo-user' }; _videos.push(n); return n; } const res = await fetch(`${API_BASE_URL}/summaries/${summaryId}/videos`, { method: 'POST', headers: authHeaders(), body: JSON.stringify(video) }); return (await res.json()).data; }
export async function updateVideo(summaryId: string, videoId: string, data: Partial<Video>): Promise<Video> { if (USE_MOCKS) { await delay(); const i = _videos.findIndex(v => v.id === videoId); if (i === -1) throw new Error(`Video ${videoId} not found`); _videos[i] = { ..._videos[i], ...data, updated_at: now() }; return _videos[i]; } const res = await fetch(`${API_BASE_URL}/summaries/${summaryId}/videos/${videoId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) }); return (await res.json()).data; }
export async function deleteVideo(summaryId: string, videoId: string): Promise<void> { if (USE_MOCKS) { await delay(); _videos = _videos.filter(v => v.id !== videoId); return; } await fetch(`${API_BASE_URL}/summaries/${summaryId}/videos/${videoId}`, { method: 'DELETE', headers: authHeaders() }); }

// Admin Scopes
export async function getAdminScopes(instId: string): Promise<AdminScope[]> { if (USE_MOCKS) { await delay(); return _adminScopes.filter(s => s.institution_id === instId); } const res = await fetch(`${API_BASE_URL}/institutions/${instId}/scopes`, { headers: authHeaders() }); return (await res.json()).data; }
export async function createAdminScope(instId: string, scope: Partial<AdminScope>): Promise<AdminScope> { if (USE_MOCKS) { await delay(); const n: AdminScope = { id: mockId('scope'), institution_id: instId, user_id: scope.user_id || '', scope_type: scope.scope_type || 'course', scope_id: scope.scope_id, role: scope.role || 'professor', created_at: now() }; _adminScopes.push(n); return n; } const res = await fetch(`${API_BASE_URL}/institutions/${instId}/scopes`, { method: 'POST', headers: authHeaders(), body: JSON.stringify(scope) }); return (await res.json()).data; }

// ══ KwStudentNotes (SACRED soft-delete) ══
export async function getKwStudentNotes(keywordId: string): Promise<KwStudentNote[]> { if (USE_MOCKS) { await delay(); return _kwStudentNotes.filter(n => n.keyword_id === keywordId); } const res = await fetch(`${API_BASE_URL}/keywords/${keywordId}/student-notes`, { headers: authHeaders() }); return (await res.json()).data; }
export async function createKwStudentNote(keywordId: string, content: string): Promise<KwStudentNote> { if (USE_MOCKS) { await delay(); const n: KwStudentNote = { id: mockId('kw-note'), keyword_id: keywordId, student_id: 'demo-student-001', content, created_at: now(), updated_at: now(), deleted_at: null }; _kwStudentNotes.push(n); return n; } const res = await fetch(`${API_BASE_URL}/keywords/${keywordId}/student-notes`, { method: 'POST', headers: authHeaders(), body: JSON.stringify({ content }) }); return (await res.json()).data; }
export async function updateKwStudentNote(keywordId: string, noteId: string, content: string): Promise<KwStudentNote> { if (USE_MOCKS) { await delay(); const i = _kwStudentNotes.findIndex(n => n.id === noteId); if (i === -1) throw new Error(`Note ${noteId} not found`); _kwStudentNotes[i] = { ..._kwStudentNotes[i], content, updated_at: now() }; return _kwStudentNotes[i]; } const res = await fetch(`${API_BASE_URL}/keywords/${keywordId}/student-notes/${noteId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify({ content }) }); return (await res.json()).data; }
export async function deleteKwStudentNote(keywordId: string, noteId: string): Promise<{ deleted: true }> { if (USE_MOCKS) { await delay(); const i = _kwStudentNotes.findIndex(n => n.id === noteId); if (i === -1) throw new Error(`Note ${noteId} not found`); _kwStudentNotes[i] = { ..._kwStudentNotes[i], deleted_at: now(), updated_at: now() }; return { deleted: true }; } const res = await fetch(`${API_BASE_URL}/keywords/${keywordId}/student-notes/${noteId}`, { method: 'DELETE', headers: authHeaders() }); return (await res.json()).data; }
export async function restoreKwStudentNote(keywordId: string, noteId: string): Promise<KwStudentNote> { if (USE_MOCKS) { await delay(); const i = _kwStudentNotes.findIndex(n => n.id === noteId); if (i === -1) throw new Error(`Note ${noteId} not found`); _kwStudentNotes[i] = { ..._kwStudentNotes[i], deleted_at: null, updated_at: now() }; return _kwStudentNotes[i]; } const res = await fetch(`${API_BASE_URL}/keywords/${keywordId}/student-notes/${noteId}/restore`, { method: 'POST', headers: authHeaders() }); return (await res.json()).data; }

// KwProfNotes
export async function getKwProfNotes(keywordId: string): Promise<KwProfNote[]> { if (USE_MOCKS) { await delay(); return _kwProfNotes.filter(n => n.keyword_id === keywordId); } const res = await fetch(`${API_BASE_URL}/keywords/${keywordId}/prof-notes`, { headers: authHeaders() }); return (await res.json()).data; }
export async function toggleKwProfNoteVisibility(keywordId: string, noteId: string, hidden: boolean): Promise<void> { if (USE_MOCKS) { await delay(); const i = _kwProfNotes.findIndex(n => n.id === noteId); if (i === -1) throw new Error(`Prof note ${noteId} not found`); _kwProfNotes[i] = { ..._kwProfNotes[i], visibility: hidden ? 'hidden' : 'visible', updated_at: now() }; return; } await fetch(`${API_BASE_URL}/keywords/${keywordId}/prof-notes/${noteId}/visibility`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify({ hidden }) }); }

// ══ VideoNotes (SACRED soft-delete) ══
export async function getVideoNotes(videoId: string): Promise<VideoNote[]> { if (USE_MOCKS) { await delay(); return _videoNotes.filter(n => n.video_id === videoId); } const res = await fetch(`${API_BASE_URL}/videos/${videoId}/notes`, { headers: authHeaders() }); return (await res.json()).data; }
export async function createVideoNote(videoId: string, content: string, timestamp_ms?: number): Promise<VideoNote> { if (USE_MOCKS) { await delay(); const n: VideoNote = { id: mockId('vnote'), video_id: videoId, student_id: 'demo-student-001', content, timestamp_ms: timestamp_ms ?? null, created_at: now(), updated_at: now(), deleted_at: null }; _videoNotes.push(n); return n; } const res = await fetch(`${API_BASE_URL}/videos/${videoId}/notes`, { method: 'POST', headers: authHeaders(), body: JSON.stringify({ content, timestamp_ms }) }); return (await res.json()).data; }
export async function updateVideoNote(videoId: string, noteId: string, data: Partial<VideoNote>): Promise<VideoNote> { if (USE_MOCKS) { await delay(); const i = _videoNotes.findIndex(n => n.id === noteId); if (i === -1) throw new Error(`Video note ${noteId} not found`); _videoNotes[i] = { ..._videoNotes[i], ...data, updated_at: now() }; return _videoNotes[i]; } const res = await fetch(`${API_BASE_URL}/videos/${videoId}/notes/${noteId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) }); return (await res.json()).data; }
export async function deleteVideoNote(videoId: string, noteId: string): Promise<{ deleted: true }> { if (USE_MOCKS) { await delay(); const i = _videoNotes.findIndex(n => n.id === noteId); if (i === -1) throw new Error(`Video note ${noteId} not found`); _videoNotes[i] = { ..._videoNotes[i], deleted_at: now(), updated_at: now() }; return { deleted: true }; } const res = await fetch(`${API_BASE_URL}/videos/${videoId}/notes/${noteId}`, { method: 'DELETE', headers: authHeaders() }); return (await res.json()).data; }
export async function restoreVideoNote(videoId: string, noteId: string): Promise<VideoNote> { if (USE_MOCKS) { await delay(); const i = _videoNotes.findIndex(n => n.id === noteId); if (i === -1) throw new Error(`Video note ${noteId} not found`); _videoNotes[i] = { ..._videoNotes[i], deleted_at: null, updated_at: now() }; return _videoNotes[i]; } const res = await fetch(`${API_BASE_URL}/videos/${videoId}/notes/${noteId}/restore`, { method: 'POST', headers: authHeaders() }); return (await res.json()).data; }

// Quiz
export async function getQuizAttempts(studentId: string, filters?: { keyword_id?: string; quiz_type?: string }): Promise<QuizAttempt[]> { if (USE_MOCKS) { await delay(); let r = _quizAttempts.filter(a => a.student_id === studentId); if (filters?.keyword_id) r = r.filter(a => a.keyword_id === filters.keyword_id); if (filters?.quiz_type) r = r.filter(a => a.quiz_type === filters.quiz_type); return r; } const p = new URLSearchParams({ student_id: studentId }); if (filters?.keyword_id) p.set('keyword_id', filters.keyword_id); if (filters?.quiz_type) p.set('quiz_type', filters.quiz_type); const res = await fetch(`${API_BASE_URL}/quiz-attempts?${p}`, { headers: authHeaders() }); return (await res.json()).data; }
export async function completeQuizSession(studentId: string, sessionId: string, attemptIds: string[]): Promise<QuizBundle> { if (USE_MOCKS) { await delay(); const atts = _quizAttempts.filter(a => attemptIds.includes(a.id)); const ts = atts.reduce((s, a) => s + a.score, 0); const tq = atts.reduce((s, a) => s + a.total_questions, 0); return { session_id: sessionId, attempts: atts, summary: { total_score: ts, total_questions: tq, average_score: tq > 0 ? ts / atts.length : 0 } }; } const res = await fetch(`${API_BASE_URL}/quiz-sessions/complete`, { method: 'POST', headers: authHeaders(), body: JSON.stringify({ student_id: studentId, session_id: sessionId, attempt_ids: attemptIds }) }); return (await res.json()).data; }

// Learning Profile
export async function getLearningProfile(studentId: string): Promise<LearningProfile | null> { if (USE_MOCKS) { await delay(); if (studentId === MOCK_LEARNING_PROFILE.student_id) return { ...MOCK_LEARNING_PROFILE }; return null; } const res = await fetch(`${API_BASE_URL}/students/${studentId}/learning-profile`, { headers: authHeaders() }); return (await res.json()).data; }

// ══ TextAnnotations (SACRED soft-delete) ══
export async function getTextAnnotations(summaryId: string): Promise<TextAnnotation[]> { if (USE_MOCKS) { await delay(); return _textAnnotations.filter(a => a.summary_id === summaryId); } const res = await fetch(`${API_BASE_URL}/summaries/${summaryId}/annotations`, { headers: authHeaders() }); return (await res.json()).data; }
export async function createTextAnnotation(summaryId: string, ann: Partial<TextAnnotation>): Promise<TextAnnotation> { if (USE_MOCKS) { await delay(); const n: TextAnnotation = { id: mockId('ann'), summary_id: summaryId, student_id: 'demo-student-001', original_text: ann.original_text || '', display_text: ann.display_text || ann.original_text || '', color: ann.color || 'yellow', note: ann.note || '', type: ann.type || 'highlight', bot_reply: ann.bot_reply, created_at: now(), updated_at: now(), deleted_at: null }; _textAnnotations.push(n); return n; } const res = await fetch(`${API_BASE_URL}/summaries/${summaryId}/annotations`, { method: 'POST', headers: authHeaders(), body: JSON.stringify(ann) }); return (await res.json()).data; }
export async function updateTextAnnotation(summaryId: string, annId: string, data: Partial<TextAnnotation>): Promise<TextAnnotation> { if (USE_MOCKS) { await delay(); const i = _textAnnotations.findIndex(a => a.id === annId); if (i === -1) throw new Error(`Annotation ${annId} not found`); _textAnnotations[i] = { ..._textAnnotations[i], ...data, updated_at: now() }; return _textAnnotations[i]; } const res = await fetch(`${API_BASE_URL}/summaries/${summaryId}/annotations/${annId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) }); return (await res.json()).data; }
export async function deleteTextAnnotation(summaryId: string, annId: string): Promise<{ deleted: true }> { if (USE_MOCKS) { await delay(); const i = _textAnnotations.findIndex(a => a.id === annId); if (i === -1) throw new Error(`Annotation ${annId} not found`); _textAnnotations[i] = { ..._textAnnotations[i], deleted_at: now(), updated_at: now() }; return { deleted: true }; } const res = await fetch(`${API_BASE_URL}/summaries/${summaryId}/annotations/${annId}`, { method: 'DELETE', headers: authHeaders() }); return (await res.json()).data; }
export async function restoreTextAnnotation(summaryId: string, annId: string): Promise<TextAnnotation> { if (USE_MOCKS) { await delay(); const i = _textAnnotations.findIndex(a => a.id === annId); if (i === -1) throw new Error(`Annotation ${annId} not found`); _textAnnotations[i] = { ..._textAnnotations[i], deleted_at: null, updated_at: now() }; return _textAnnotations[i]; } const res = await fetch(`${API_BASE_URL}/summaries/${summaryId}/annotations/${annId}/restore`, { method: 'POST', headers: authHeaders() }); return (await res.json()).data; }

// Reading State
export async function getReadingState(summaryId: string, studentId: string): Promise<SummaryReadingState | null> { if (USE_MOCKS) { await delay(); return _readingStates.find(r => r.summary_id === summaryId && r.student_id === studentId) || null; } const res = await fetch(`${API_BASE_URL}/summaries/${summaryId}/reading-state?student_id=${studentId}`, { headers: authHeaders() }); return (await res.json()).data; }
export async function updateReadingState(summaryId: string, studentId: string, data: Partial<SummaryReadingState>): Promise<SummaryReadingState> { if (USE_MOCKS) { await delay(); const i = _readingStates.findIndex(r => r.summary_id === summaryId && r.student_id === studentId); if (i >= 0) { _readingStates[i] = { ..._readingStates[i], ...data, last_read_at: now() }; return _readingStates[i]; } const n: SummaryReadingState = { summary_id: summaryId, student_id: studentId, progress_percent: data.progress_percent ?? 0, last_position: data.last_position ?? 0, time_spent_seconds: data.time_spent_seconds ?? 0, completed: data.completed ?? false, last_read_at: now() }; _readingStates.push(n); return n; } const res = await fetch(`${API_BASE_URL}/summaries/${summaryId}/reading-state`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify({ student_id: studentId, ...data }) }); return (await res.json()).data; }

// Student Stats
export async function getStudentStats(studentId: string): Promise<StudentStats> { if (USE_MOCKS) { await delay(); return { ...MOCK_STUDENT_STATS }; } const res = await fetch(`${API_BASE_URL}/students/${studentId}/stats`, { headers: authHeaders() }); return (await res.json()).data; }
export async function updateStudentStats(studentId: string, data: Partial<StudentStats>): Promise<StudentStats> { if (USE_MOCKS) { await delay(); return { ...MOCK_STUDENT_STATS, ...data }; } const res = await fetch(`${API_BASE_URL}/students/${studentId}/stats`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) }); return (await res.json()).data; }
export async function getDailyActivity(studentId: string, days = 7): Promise<DailyActivity[]> { if (USE_MOCKS) { await delay(); return [...MOCK_DAILY_ACTIVITY].slice(-days); } const res = await fetch(`${API_BASE_URL}/students/${studentId}/daily-activity?days=${days}`, { headers: authHeaders() }); return (await res.json()).data; }
export async function getCourseProgress(studentId: string): Promise<CourseProgress[]> { if (USE_MOCKS) { await delay(); return [...MOCK_COURSE_PROGRESS]; } const res = await fetch(`${API_BASE_URL}/students/${studentId}/course-progress`, { headers: authHeaders() }); return (await res.json()).data; }

// ══ Student Profile (P3) ══
export async function getStudentProfile(studentId: string): Promise<StudentProfile | null> { if (USE_MOCKS) { await delay(); if (studentId === MOCK_STUDENT_PROFILE.id) return { ...MOCK_STUDENT_PROFILE }; return null; } const res = await fetch(`${API_BASE_URL}/students/${studentId}/profile`, { headers: authHeaders() }); return (await res.json()).data; }
export async function updateStudentProfile(studentId: string, data: Partial<StudentProfile>): Promise<StudentProfile> { if (USE_MOCKS) { await delay(); const i = _studentProfiles.findIndex(p => p.id === studentId); if (i === -1) throw new Error(`Student profile ${studentId} not found`); _studentProfiles[i] = { ..._studentProfiles[i], ...data, updated_at: now() }; return _studentProfiles[i]; } const res = await fetch(`${API_BASE_URL}/students/${studentId}/profile`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) }); return (await res.json()).data; }

// ══ Study Sessions (P3) ══
export async function getStudySessions(studentId: string): Promise<StudySession[]> { if (USE_MOCKS) { await delay(); return _studySessions.filter(s => s.student_id === studentId); } const res = await fetch(`${API_BASE_URL}/students/${studentId}/study-sessions`, { headers: authHeaders() }); return (await res.json()).data; }
export async function createStudySession(studentId: string, session: Partial<StudySession>): Promise<StudySession> { if (USE_MOCKS) { await delay(); const n: StudySession = { id: mockId('session'), student_id: studentId, course_id: session.course_id || '', topic_id: session.topic_id, started_at: session.started_at || now(), ended_at: session.ended_at || now(), duration_minutes: session.duration_minutes || 0, activity_type: session.activity_type || 'mixed' }; _studySessions.push(n); return n; } const res = await fetch(`${API_BASE_URL}/students/${studentId}/study-sessions`, { method: 'POST', headers: authHeaders(), body: JSON.stringify(session) }); return (await res.json()).data; }
export async function updateStudySession(studentId: string, sessionId: string, data: Partial<StudySession>): Promise<StudySession> { if (USE_MOCKS) { await delay(); const i = _studySessions.findIndex(s => s.id === sessionId); if (i === -1) throw new Error(`Study session ${sessionId} not found`); _studySessions[i] = { ..._studySessions[i], ...data }; return _studySessions[i]; } const res = await fetch(`${API_BASE_URL}/students/${studentId}/study-sessions/${sessionId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) }); return (await res.json()).data; }
export async function deleteStudySession(studentId: string, sessionId: string): Promise<void> { if (USE_MOCKS) { await delay(); _studySessions = _studySessions.filter(s => s.id !== sessionId); return; } await fetch(`${API_BASE_URL}/students/${studentId}/study-sessions/${sessionId}`, { method: 'DELETE', headers: authHeaders() }); }

// ══ Flashcard Reviews (P3) ══
export async function getFlashcardReviews(studentId: string): Promise<FlashcardReview[]> { if (USE_MOCKS) { await delay(); return _flashcardReviews.filter(r => r.student_id === studentId); } const res = await fetch(`${API_BASE_URL}/students/${studentId}/flashcard-reviews`, { headers: authHeaders() }); return (await res.json()).data; }
export async function createFlashcardReview(studentId: string, review: Partial<FlashcardReview>): Promise<FlashcardReview> { if (USE_MOCKS) { await delay(); const n: FlashcardReview = { id: mockId('review'), student_id: studentId, card_id: review.card_id || '', course_id: review.course_id || '', rating: review.rating || 0, reviewed_at: review.reviewed_at || now() }; _flashcardReviews.push(n); return n; } const res = await fetch(`${API_BASE_URL}/students/${studentId}/flashcard-reviews`, { method: 'POST', headers: authHeaders(), body: JSON.stringify(review) }); return (await res.json()).data; }
export async function updateFlashcardReview(studentId: string, reviewId: string, data: Partial<FlashcardReview>): Promise<FlashcardReview> { if (USE_MOCKS) { await delay(); const i = _flashcardReviews.findIndex(r => r.id === reviewId); if (i === -1) throw new Error(`Flashcard review ${reviewId} not found`); _flashcardReviews[i] = { ..._flashcardReviews[i], ...data }; return _flashcardReviews[i]; } const res = await fetch(`${API_BASE_URL}/students/${studentId}/flashcard-reviews/${reviewId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) }); return (await res.json()).data; }
export async function deleteFlashcardReview(studentId: string, reviewId: string): Promise<void> { if (USE_MOCKS) { await delay(); _flashcardReviews = _flashcardReviews.filter(r => r.id !== reviewId); return; } await fetch(`${API_BASE_URL}/students/${studentId}/flashcard-reviews/${reviewId}`, { method: 'DELETE', headers: authHeaders() }); }

// ══ Study Summaries (P3) ══
export async function getStudySummaries(studentId: string): Promise<StudySummary[]> { if (USE_MOCKS) { await delay(); return _studySummaries.filter(s => s.student_id === studentId); } const res = await fetch(`${API_BASE_URL}/students/${studentId}/study-summaries`, { headers: authHeaders() }); return (await res.json()).data; }
export async function createStudySummary(studentId: string, summary: Partial<StudySummary>): Promise<StudySummary> { if (USE_MOCKS) { await delay(); const n: StudySummary = { id: mockId('study-sum'), student_id: studentId, course_id: summary.course_id || '', topic_id: summary.topic_id || '', course_name: summary.course_name || '', topic_title: summary.topic_title || '', content: summary.content || '', annotations: summary.annotations || [], keyword_mastery: summary.keyword_mastery || {}, keyword_notes: summary.keyword_notes || {}, edit_time_minutes: summary.edit_time_minutes || 0, tags: summary.tags || [], bookmarked: summary.bookmarked || false, created_at: now(), updated_at: now() }; _studySummaries.push(n); return n; } const res = await fetch(`${API_BASE_URL}/students/${studentId}/study-summaries`, { method: 'POST', headers: authHeaders(), body: JSON.stringify(summary) }); return (await res.json()).data; }
export async function updateStudySummary(studentId: string, summaryId: string, data: Partial<StudySummary>): Promise<StudySummary> { if (USE_MOCKS) { await delay(); const i = _studySummaries.findIndex(s => s.id === summaryId); if (i === -1) throw new Error(`Study summary ${summaryId} not found`); _studySummaries[i] = { ..._studySummaries[i], ...data, updated_at: now() }; return _studySummaries[i]; } const res = await fetch(`${API_BASE_URL}/students/${studentId}/study-summaries/${summaryId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) }); return (await res.json()).data; }
export async function deleteStudySummary(studentId: string, summaryId: string): Promise<void> { if (USE_MOCKS) { await delay(); _studySummaries = _studySummaries.filter(s => s.id !== summaryId); return; } await fetch(`${API_BASE_URL}/students/${studentId}/study-summaries/${summaryId}`, { method: 'DELETE', headers: authHeaders() }); }
export async function getStudySummaryByTopic(studentId: string, courseId: string, topicId: string): Promise<StudySummary | null> { if (USE_MOCKS) { await delay(); return _studySummaries.find(s => s.student_id === studentId && s.course_id === courseId && s.topic_id === topicId) || null; } const res = await fetch(`${API_BASE_URL}/students/${studentId}/study-summaries/${courseId}/${topicId}`, { headers: authHeaders() }); if (res.status === 404) return null; return (await res.json()).data; }
export async function saveStudySummaryByTopic(studentId: string, courseId: string, topicId: string, data: Partial<StudySummary>): Promise<StudySummary> { if (USE_MOCKS) { await delay(); const i = _studySummaries.findIndex(s => s.student_id === studentId && s.course_id === courseId && s.topic_id === topicId); if (i >= 0) { _studySummaries[i] = { ..._studySummaries[i], ...data, updated_at: now() }; return _studySummaries[i]; } const n: StudySummary = { id: mockId('study-sum'), student_id: studentId, course_id: courseId, topic_id: topicId, course_name: data.course_name || '', topic_title: data.topic_title || '', content: data.content || '', annotations: data.annotations || [], keyword_mastery: data.keyword_mastery || {}, keyword_notes: data.keyword_notes || {}, edit_time_minutes: data.edit_time_minutes || 0, tags: data.tags || [], bookmarked: data.bookmarked || false, created_at: now(), updated_at: now() }; _studySummaries.push(n); return n; } const res = await fetch(`${API_BASE_URL}/students/${studentId}/study-summaries/${courseId}/${topicId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) }); return (await res.json()).data; }

// ══ Content Hierarchy CRUD (P3) ══
export async function getCourses(instId: string): Promise<Course[]> { if (USE_MOCKS) { await delay(); return _courses.filter(c => c.institution_id === instId); } const res = await fetch(`${API_BASE_URL}/institutions/${instId}/courses`, { headers: authHeaders() }); return (await res.json()).data; }
export async function createCourse(instId: string, course: Partial<Course>): Promise<Course> { if (USE_MOCKS) { await delay(); const n: Course = { id: mockId('course'), institution_id: instId, name: course.name || 'Novo Curso', description: course.description ?? null, color: course.color || '#6366f1', sort_order: course.sort_order ?? _courses.filter(c => c.institution_id === instId).length, created_at: now(), updated_at: now(), created_by: course.created_by }; _courses.push(n); return n; } const res = await fetch(`${API_BASE_URL}/institutions/${instId}/courses`, { method: 'POST', headers: authHeaders(), body: JSON.stringify(course) }); return (await res.json()).data; }
export async function updateCourse(instId: string, courseId: string, data: Partial<Course>): Promise<Course> { if (USE_MOCKS) { await delay(); const i = _courses.findIndex(c => c.id === courseId); if (i === -1) throw new Error(`Course ${courseId} not found`); _courses[i] = { ..._courses[i], ...data, updated_at: now() }; return _courses[i]; } const res = await fetch(`${API_BASE_URL}/institutions/${instId}/courses/${courseId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) }); return (await res.json()).data; }
export async function deleteCourse(instId: string, courseId: string): Promise<void> { if (USE_MOCKS) { await delay(); _courses = _courses.filter(c => c.id !== courseId); return; } await fetch(`${API_BASE_URL}/institutions/${instId}/courses/${courseId}`, { method: 'DELETE', headers: authHeaders() }); }

export async function getSemesters(courseId: string): Promise<Semester[]> { if (USE_MOCKS) { await delay(); return _semesters.filter(s => s.course_id === courseId); } const res = await fetch(`${API_BASE_URL}/courses/${courseId}/semesters`, { headers: authHeaders() }); return (await res.json()).data; }
export async function createSemester(courseId: string, sem: Partial<Semester>): Promise<Semester> { if (USE_MOCKS) { await delay(); const n: Semester = { id: mockId('semester'), course_id: courseId, name: sem.name || 'Novo Semestre', order_index: sem.order_index ?? _semesters.filter(s => s.course_id === courseId).length }; _semesters.push(n); return n; } const res = await fetch(`${API_BASE_URL}/courses/${courseId}/semesters`, { method: 'POST', headers: authHeaders(), body: JSON.stringify(sem) }); return (await res.json()).data; }
export async function updateSemester(courseId: string, semId: string, data: Partial<Semester>): Promise<Semester> { if (USE_MOCKS) { await delay(); const i = _semesters.findIndex(s => s.id === semId); if (i === -1) throw new Error(`Semester ${semId} not found`); _semesters[i] = { ..._semesters[i], ...data }; return _semesters[i]; } const res = await fetch(`${API_BASE_URL}/courses/${courseId}/semesters/${semId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) }); return (await res.json()).data; }
export async function deleteSemester(courseId: string, semId: string): Promise<void> { if (USE_MOCKS) { await delay(); _semesters = _semesters.filter(s => s.id !== semId); return; } await fetch(`${API_BASE_URL}/courses/${courseId}/semesters/${semId}`, { method: 'DELETE', headers: authHeaders() }); }

export async function getSections(semesterId: string): Promise<Section[]> { if (USE_MOCKS) { await delay(); return _sections.filter(s => s.semester_id === semesterId); } const res = await fetch(`${API_BASE_URL}/semesters/${semesterId}/sections`, { headers: authHeaders() }); return (await res.json()).data; }
export async function createSection(semesterId: string, sec: Partial<Section>): Promise<Section> { if (USE_MOCKS) { await delay(); const n: Section = { id: mockId('section'), semester_id: semesterId, name: sec.name || 'Nova Secao', image_url: sec.image_url ?? null, order_index: sec.order_index ?? _sections.filter(s => s.semester_id === semesterId).length }; _sections.push(n); return n; } const res = await fetch(`${API_BASE_URL}/semesters/${semesterId}/sections`, { method: 'POST', headers: authHeaders(), body: JSON.stringify(sec) }); return (await res.json()).data; }
export async function updateSection(semesterId: string, secId: string, data: Partial<Section>): Promise<Section> { if (USE_MOCKS) { await delay(); const i = _sections.findIndex(s => s.id === secId); if (i === -1) throw new Error(`Section ${secId} not found`); _sections[i] = { ..._sections[i], ...data }; return _sections[i]; } const res = await fetch(`${API_BASE_URL}/semesters/${semesterId}/sections/${secId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) }); return (await res.json()).data; }
export async function deleteSection(semesterId: string, secId: string): Promise<void> { if (USE_MOCKS) { await delay(); _sections = _sections.filter(s => s.id !== secId); return; } await fetch(`${API_BASE_URL}/semesters/${semesterId}/sections/${secId}`, { method: 'DELETE', headers: authHeaders() }); }

export async function getTopics(sectionId: string): Promise<Topic[]> { if (USE_MOCKS) { await delay(); return _topics.filter(t => t.section_id === sectionId); } const res = await fetch(`${API_BASE_URL}/sections/${sectionId}/topics`, { headers: authHeaders() }); return (await res.json()).data; }
export async function createTopic(sectionId: string, topic: Partial<Topic>): Promise<Topic> { if (USE_MOCKS) { await delay(); const n: Topic = { id: mockId('topic'), section_id: sectionId, name: topic.name || 'Novo Topico', order_index: topic.order_index ?? _topics.filter(t => t.section_id === sectionId).length, created_at: now() }; _topics.push(n); return n; } const res = await fetch(`${API_BASE_URL}/sections/${sectionId}/topics`, { method: 'POST', headers: authHeaders(), body: JSON.stringify(topic) }); return (await res.json()).data; }
export async function updateTopic(sectionId: string, topicId: string, data: Partial<Topic>): Promise<Topic> { if (USE_MOCKS) { await delay(); const i = _topics.findIndex(t => t.id === topicId); if (i === -1) throw new Error(`Topic ${topicId} not found`); _topics[i] = { ..._topics[i], ...data }; return _topics[i]; } const res = await fetch(`${API_BASE_URL}/sections/${sectionId}/topics/${topicId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) }); return (await res.json()).data; }
export async function deleteTopic(sectionId: string, topicId: string): Promise<void> { if (USE_MOCKS) { await delay(); _topics = _topics.filter(t => t.id !== topicId); return; } await fetch(`${API_BASE_URL}/sections/${sectionId}/topics/${topicId}`, { method: 'DELETE', headers: authHeaders() }); }

export async function getSummaries(topicId: string): Promise<Summary[]> { if (USE_MOCKS) { await delay(); return _summaries.filter(s => s.topic_id === topicId); } const res = await fetch(`${API_BASE_URL}/topics/${topicId}/summaries`, { headers: authHeaders() }); return (await res.json()).data; }
export async function createSummary(topicId: string, sum: Partial<Summary>): Promise<Summary> { if (USE_MOCKS) { await delay(); const n: Summary = { id: mockId('summary'), topic_id: topicId, course_id: sum.course_id || '', institution_id: sum.institution_id, content_markdown: sum.content_markdown || '', status: sum.status || 'draft', created_by: sum.created_by || 'demo-user', created_at: now(), updated_at: now(), version: sum.version || 1 }; _summaries.push(n); return n; } const res = await fetch(`${API_BASE_URL}/topics/${topicId}/summaries`, { method: 'POST', headers: authHeaders(), body: JSON.stringify(sum) }); return (await res.json()).data; }
export async function updateSummary(topicId: string, sumId: string, data: Partial<Summary>): Promise<Summary> { if (USE_MOCKS) { await delay(); const i = _summaries.findIndex(s => s.id === sumId); if (i === -1) throw new Error(`Summary ${sumId} not found`); _summaries[i] = { ..._summaries[i], ...data, updated_at: now() }; return _summaries[i]; } const res = await fetch(`${API_BASE_URL}/topics/${topicId}/summaries/${sumId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) }); return (await res.json()).data; }
export async function deleteSummary(topicId: string, sumId: string): Promise<void> { if (USE_MOCKS) { await delay(); _summaries = _summaries.filter(s => s.id !== sumId); return; } await fetch(`${API_BASE_URL}/topics/${topicId}/summaries/${sumId}`, { method: 'DELETE', headers: authHeaders() }); }

export async function getKeywords(instId: string): Promise<Keyword[]> { if (USE_MOCKS) { await delay(); return _keywords.filter(k => k.institution_id === instId); } const res = await fetch(`${API_BASE_URL}/institutions/${instId}/keywords`, { headers: authHeaders() }); return (await res.json()).data; }
export async function createKeyword(instId: string, kw: Partial<Keyword>): Promise<Keyword> { if (USE_MOCKS) { await delay(); const n: Keyword = { id: mockId('keyword'), institution_id: instId, term: kw.term || 'Novo Termo', definition: kw.definition ?? null, priority: kw.priority ?? 0, status: kw.status || 'draft', source: kw.source, created_by: kw.created_by || 'demo-user', created_at: now(), updated_at: now() }; _keywords.push(n); return n; } const res = await fetch(`${API_BASE_URL}/institutions/${instId}/keywords`, { method: 'POST', headers: authHeaders(), body: JSON.stringify(kw) }); return (await res.json()).data; }
export async function updateKeyword(instId: string, kwId: string, data: Partial<Keyword>): Promise<Keyword> { if (USE_MOCKS) { await delay(); const i = _keywords.findIndex(k => k.id === kwId); if (i === -1) throw new Error(`Keyword ${kwId} not found`); _keywords[i] = { ..._keywords[i], ...data, updated_at: now() }; return _keywords[i]; } const res = await fetch(`${API_BASE_URL}/institutions/${instId}/keywords/${kwId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) }); return (await res.json()).data; }
export async function deleteKeyword(instId: string, kwId: string): Promise<void> { if (USE_MOCKS) { await delay(); _keywords = _keywords.filter(k => k.id !== kwId); return; } await fetch(`${API_BASE_URL}/institutions/${instId}/keywords/${kwId}`, { method: 'DELETE', headers: authHeaders() }); }

// Seed
export async function seedDemoData(): Promise<{ ok: boolean; message: string }> { if (USE_MOCKS) { await delay(); return { ok: true, message: 'Mock data already loaded' }; } const res = await fetch(`${API_BASE_URL}/seed`, { method: 'POST', headers: authHeaders() }); return res.json(); }

// Bulk Content Hierarchy (useContentData)
export async function fetchContentHierarchy(): Promise<{ courses: Course[]; semesters: Semester[]; sections: Section[]; topics: Topic[]; summaries: Summary[]; keywords: Keyword[] }> { if (USE_MOCKS) { await delay(); return { courses: [..._courses], semesters: [..._semesters], sections: [..._sections], topics: [..._topics], summaries: [..._summaries], keywords: [..._keywords] }; } const [courses, semesters, sections, topics, summaries, keywords] = await Promise.all([ fetch(`${API_BASE_URL}/courses`, { headers: authHeaders() }).then(r => r.json()).then(j => j.data || []), fetch(`${API_BASE_URL}/semesters`, { headers: authHeaders() }).then(r => r.json()).then(j => j.data || []), fetch(`${API_BASE_URL}/sections`, { headers: authHeaders() }).then(r => r.json()).then(j => j.data || []), fetch(`${API_BASE_URL}/topics`, { headers: authHeaders() }).then(r => r.json()).then(j => j.data || []), fetch(`${API_BASE_URL}/summaries`, { headers: authHeaders() }).then(r => r.json()).then(j => j.data || []), fetch(`${API_BASE_URL}/keywords`, { headers: authHeaders() }).then(r => r.json()).then(j => j.data || []) ]); return { courses, semesters, sections, topics, summaries, keywords }; }
