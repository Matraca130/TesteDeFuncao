// Axon v4.4 â€” API: SACRED entities (soft-delete only)
import type { KwStudentNote, KwProfNote, VideoNote, TextAnnotation } from './types';
import { USE_MOCKS, API_BASE_URL, authHeaders, store, mockId, delay, now } from './api-core';

// KwStudentNotes
export async function getKwStudentNotes(kwId: string): Promise<KwStudentNote[]> { if (USE_MOCKS) { await delay(); return store.kwStudentNotes.filter(n => n.keyword_id === kwId); } return (await (await fetch(`${API_BASE_URL}/keywords/${kwId}/student-notes`, { headers: authHeaders() })).json()).data; }
export async function createKwStudentNote(kwId: string, content: string): Promise<KwStudentNote> { if (USE_MOCKS) { await delay(); const n: KwStudentNote = { id: mockId('kw-note'), keyword_id: kwId, student_id: 'demo-student-001', content, created_at: now(), updated_at: now(), deleted_at: null }; store.kwStudentNotes.push(n); return n; } return (await (await fetch(`${API_BASE_URL}/keywords/${kwId}/student-notes`, { method: 'POST', headers: authHeaders(), body: JSON.stringify({ content }) })).json()).data; }
export async function updateKwStudentNote(kwId: string, noteId: string, content: string): Promise<KwStudentNote> { if (USE_MOCKS) { await delay(); const i = store.kwStudentNotes.findIndex(n => n.id === noteId); if (i === -1) throw new Error(`Note ${noteId} not found`); store.kwStudentNotes[i] = { ...store.kwStudentNotes[i], content, updated_at: now() }; return store.kwStudentNotes[i]; } return (await (await fetch(`${API_BASE_URL}/keywords/${kwId}/student-notes/${noteId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify({ content }) })).json()).data; }
export async function deleteKwStudentNote(kwId: string, noteId: string): Promise<{ deleted: true }> { if (USE_MOCKS) { await delay(); const i = store.kwStudentNotes.findIndex(n => n.id === noteId); if (i === -1) throw new Error(`Note ${noteId} not found`); store.kwStudentNotes[i] = { ...store.kwStudentNotes[i], deleted_at: now(), updated_at: now() }; return { deleted: true }; } return (await (await fetch(`${API_BASE_URL}/keywords/${kwId}/student-notes/${noteId}`, { method: 'DELETE', headers: authHeaders() })).json()).data; }
export async function restoreKwStudentNote(kwId: string, noteId: string): Promise<KwStudentNote> { if (USE_MOCKS) { await delay(); const i = store.kwStudentNotes.findIndex(n => n.id === noteId); if (i === -1) throw new Error(`Note ${noteId} not found`); store.kwStudentNotes[i] = { ...store.kwStudentNotes[i], deleted_at: null, updated_at: now() }; return store.kwStudentNotes[i]; } return (await (await fetch(`${API_BASE_URL}/keywords/${kwId}/student-notes/${noteId}/restore`, { method: 'POST', headers: authHeaders() })).json()).data; }

// KwProfNotes
export async function getKwProfNotes(kwId: string): Promise<KwProfNote[]> { if (USE_MOCKS) { await delay(); return store.kwProfNotes.filter(n => n.keyword_id === kwId); } return (await (await fetch(`${API_BASE_URL}/keywords/${kwId}/prof-notes`, { headers: authHeaders() })).json()).data; }
export async function toggleKwProfNoteVisibility(kwId: string, noteId: string, hidden: boolean): Promise<void> { if (USE_MOCKS) { await delay(); const i = store.kwProfNotes.findIndex(n => n.id === noteId); if (i === -1) throw new Error(`Prof note ${noteId} not found`); store.kwProfNotes[i] = { ...store.kwProfNotes[i], visibility: hidden ? 'hidden' : 'visible', updated_at: now() }; return; } await fetch(`${API_BASE_URL}/keywords/${kwId}/prof-notes/${noteId}/visibility`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify({ hidden }) }); }

// VideoNotes
export async function getVideoNotes(videoId: string): Promise<VideoNote[]> { if (USE_MOCKS) { await delay(); return store.videoNotes.filter(n => n.video_id === videoId); } return (await (await fetch(`${API_BASE_URL}/videos/${videoId}/notes`, { headers: authHeaders() })).json()).data; }
export async function createVideoNote(videoId: string, content: string, timestamp_ms?: number): Promise<VideoNote> { if (USE_MOCKS) { await delay(); const n: VideoNote = { id: mockId('vnote'), video_id: videoId, student_id: 'demo-student-001', content, timestamp_ms: timestamp_ms ?? null, created_at: now(), updated_at: now(), deleted_at: null }; store.videoNotes.push(n); return n; } return (await (await fetch(`${API_BASE_URL}/videos/${videoId}/notes`, { method: 'POST', headers: authHeaders(), body: JSON.stringify({ content, timestamp_ms }) })).json()).data; }
export async function updateVideoNote(videoId: string, noteId: string, data: Partial<VideoNote>): Promise<VideoNote> { if (USE_MOCKS) { await delay(); const i = store.videoNotes.findIndex(n => n.id === noteId); if (i === -1) throw new Error(`Video note ${noteId} not found`); store.videoNotes[i] = { ...store.videoNotes[i], ...data, updated_at: now() }; return store.videoNotes[i]; } return (await (await fetch(`${API_BASE_URL}/videos/${videoId}/notes/${noteId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) })).json()).data; }
export async function deleteVideoNote(videoId: string, noteId: string): Promise<{ deleted: true }> { if (USE_MOCKS) { await delay(); const i = store.videoNotes.findIndex(n => n.id === noteId); if (i === -1) throw new Error(`Video note ${noteId} not found`); store.videoNotes[i] = { ...store.videoNotes[i], deleted_at: now(), updated_at: now() }; return { deleted: true }; } return (await (await fetch(`${API_BASE_URL}/videos/${videoId}/notes/${noteId}`, { method: 'DELETE', headers: authHeaders() })).json()).data; }
export async function restoreVideoNote(videoId: string, noteId: string): Promise<VideoNote> { if (USE_MOCKS) { await delay(); const i = store.videoNotes.findIndex(n => n.id === noteId); if (i === -1) throw new Error(`Video note ${noteId} not found`); store.videoNotes[i] = { ...store.videoNotes[i], deleted_at: null, updated_at: now() }; return store.videoNotes[i]; } return (await (await fetch(`${API_BASE_URL}/videos/${videoId}/notes/${noteId}/restore`, { method: 'POST', headers: authHeaders() })).json()).data; }

// TextAnnotations
export async function getTextAnnotations(sumId: string): Promise<TextAnnotation[]> { if (USE_MOCKS) { await delay(); return store.textAnnotations.filter(a => a.summary_id === sumId); } return (await (await fetch(`${API_BASE_URL}/summaries/${sumId}/annotations`, { headers: authHeaders() })).json()).data; }
export async function createTextAnnotation(sumId: string, ann: Partial<TextAnnotation>): Promise<TextAnnotation> { if (USE_MOCKS) { await delay(); const n: TextAnnotation = { id: mockId('ann'), summary_id: sumId, student_id: 'demo-student-001', original_text: ann.original_text || '', display_text: ann.display_text || ann.original_text || '', color: ann.color || 'yellow', note: ann.note || '', type: ann.type || 'highlight', bot_reply: ann.bot_reply, created_at: now(), updated_at: now(), deleted_at: null }; store.textAnnotations.push(n); return n; } return (await (await fetch(`${API_BASE_URL}/summaries/${sumId}/annotations`, { method: 'POST', headers: authHeaders(), body: JSON.stringify(ann) })).json()).data; }
export async function updateTextAnnotation(sumId: string, annId: string, data: Partial<TextAnnotation>): Promise<TextAnnotation> { if (USE_MOCKS) { await delay(); const i = store.textAnnotations.findIndex(a => a.id === annId); if (i === -1) throw new Error(`Annotation ${annId} not found`); store.textAnnotations[i] = { ...store.textAnnotations[i], ...data, updated_at: now() }; return store.textAnnotations[i]; } return (await (await fetch(`${API_BASE_URL}/summaries/${sumId}/annotations/${annId}`, { method: 'PUT', headers: authHeaders(), body: JSON.stringify(data) })).json()).data; }
export async function deleteTextAnnotation(sumId: string, annId: string): Promise<{ deleted: true }> { if (USE_MOCKS) { await delay(); const i = store.textAnnotations.findIndex(a => a.id === annId); if (i === -1) throw new Error(`Annotation ${annId} not found`); store.textAnnotations[i] = { ...store.textAnnotations[i], deleted_at: now(), updated_at: now() }; return { deleted: true }; } return (await (await fetch(`${API_BASE_URL}/summaries/${sumId}/annotations/${annId}`, { method: 'DELETE', headers: authHeaders() })).json()).data; }
export async function restoreTextAnnotation(sumId: string, annId: string): Promise<TextAnnotation> { if (USE_MOCKS) { await delay(); const i = store.textAnnotations.findIndex(a => a.id === annId); if (i === -1) throw new Error(`Annotation ${annId} not found`); store.textAnnotations[i] = { ...store.textAnnotations[i], deleted_at: null, updated_at: now() }; return store.textAnnotations[i]; } return (await (await fetch(`${API_BASE_URL}/summaries/${sumId}/annotations/${annId}/restore`, { method: 'POST', headers: authHeaders() })).json()).data; }
